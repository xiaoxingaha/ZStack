###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                01/Dec/2011  14:24:48 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Components\hal\target\CC2530EB\hal_ #
#                          sleep.c                                            #
#    Command line       =  -f F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò #
#                          °üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_ #
#                          Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleAp #
#                          p\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg    #
#                          (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS) -f    #
#                          F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleApp\C #
#                          C2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg      #
#                          (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR      #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Components\hal\target\CC2530EB\hal_ #
#                          sleep.c -D NWK_AUTO_POLL -D HOLD_AUTO_START -D     #
#                          REFLECTOR -D POWER_SAVING -D NV_INIT -D            #
#                          xNV_RESTORE -D xZTOOL_P1 -D xMT_TASK -D            #
#                          xMT_SYS_FUNC -D xMT_SAPI_FUNC -D xMT_SAPI_CB_FUNC  #
#                          -lC F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐ #
#                          ò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0 #
#                          _Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleA #
#                          pp\CC2530DB\SimpleSensorEB\List\ -lA               #
#                          F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleApp\C #
#                          C2530DB\SimpleSensorEB\List\ --diag_suppress       #
#                          Pe001,Pa010 -o F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10 #
#                          __CC2530³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530- #
#                          2.3.0-1.4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samp #
#                          les\SimpleApp\CC2530DB\SimpleSensorEB\Obj\ -e      #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼ #
#                          þ¹âÅÌ\10__CC2530³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack #
#                          -CC2530-2.3.0-1.4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zst #
#                          ack\Samples\SimpleApp\CC2530DB\ -I                 #
#                          F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleApp\C #
#                          C2530DB\..\SOURCE\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ #
#                          ¹âÅÌ\10__CC2530³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack- #
#                          CC2530-2.3.0-1.4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zsta #
#                          ck\Samples\SimpleApp\CC2530DB\..\..\..\ZMAIN\TI253 #
#                          0DB\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC253 #
#                          0³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1 #
#                          .4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\Sim #
#                          pleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\ -I   #
#                          F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I  #
#                          F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC253 #
#                          0EB\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC253 #
#                          0³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1 #
#                          .4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\Sim #
#                          pleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU #
#                          \CCSOC\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC #
#                          2530³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3. #
#                          0-1.4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\ #
#                          SimpleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\ #
#                          INCLUDE\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__C #
#                          C2530³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3 #
#                          .0-1.4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples #
#                          \SimpleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STAC #
#                          K\AF\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC25 #
#                          30³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0- #
#                          1.4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\Si #
#                          mpleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\N #
#                          WK\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530 #
#                          ³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1. #
#                          4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\Simp #
#                          leApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC #
#                          \ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³Ì #
#                          Ðò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4. #
#                          0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\Simple #
#                          App\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ #
#                           -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐ #
#                          ò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0 #
#                          _Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\   #
#                          -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò #
#                          °üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_ #
#                          Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleAp #
#                          p\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\    #
#                          -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò #
#                          °üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_ #
#                          Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleAp #
#                          p\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\ -I  #
#                          F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I         #
#                          F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\  #
#                          -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò #
#                          °üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_ #
#                          Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleAp #
#                          p\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDAT #
#                          A\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ #
#                          ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4 #
#                          .0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\Simpl #
#                          eApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUD #
#                          E\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ #
#                          ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4 #
#                          .0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\Simpl #
#                          eApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_L #
#                          EVEL\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC25 #
#                          30³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0- #
#                          1.4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\Si #
#                          mpleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW #
#                          _LEVEL\srf04\ -I F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\ #
#                          10__CC2530³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC253 #
#                          0-2.3.0-1.4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Sa #
#                          mples\SimpleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 5.3           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 5.3           #
#                          Evaluation version\8051\INC\CLIB\" -Ohz            #
#    List file          =  F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleApp\C #
#                          C2530DB\SimpleSensorEB\List\hal_sleep.lst          #
#    Object file        =  F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB #
#                          _Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸ #
#                          öÊµÑé_×¨ÒµÉÐÑô\Projects\zstack\Samples\SimpleApp\C #
#                          C2530DB\SimpleSensorEB\Obj\hal_sleep.r51           #
#                                                                             #
#                                                                             #
###############################################################################

F:\fancong\×ÊÁÏ\ÉÐÑô2530Ì×¼þ¹âÅÌ\10__CC2530³ÌÐò°üB_Ð­ÒéÕ»ÊµÑé\Ê®ºÍÊ®¶þ_ZStack-CC2530-2.3.0-1.4.0_Á½¸öÊµÑé_×¨ÒµÉÐÑô\Components\hal\target\CC2530EB\hal_sleep.c
      1          /**************************************************************************************************
      2            Filename:       hal_sleep.c
      3            Revised:        $Date: 2009-01-29 15:49:56 -0800 (Thu, 29 Jan 2009) $
      4            Revision:       $Revision: 18906 $
      5          
      6            Description:    This module contains the HAL power management procedures for the CC2530.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          #include "hal_types.h"
     45          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x87
   \   unsigned char volatile __sfr PCON
   \                     PCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x96
   \   unsigned char volatile __sfr ST1
   \                     ST1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x97
   \   unsigned char volatile __sfr ST2
   \                     ST2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xad
   \   unsigned char volatile __sfr STLOAD
   \                     STLOAD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1
     46          #include "hal_board.h"
     47          #include "hal_sleep.h"
     48          #include "hal_led.h"
     49          #include "hal_key.h"
     50          #include "mac_api.h"
     51          #include "OSAL.h"
     52          #include "OSAL_Timers.h"
     53          #include "OSAL_Tasks.h"
     54          #include "OSAL_PwrMgr.h"
     55          #include "OnBoard.h"
     56          #include "hal_drivers.h"
     57          #include "hal_assert.h"
     58          #include "mac_mcu.h"
     59          
     60          #if !defined (RTR_NWK) && defined (NWK_AUTO_POLL)
     61          #include "nwk_globals.h"
     62          #include "ZGlobals.h"
     63          #endif
     64          
     65          /* ------------------------------------------------------------------------------------------------
     66           *                                           Macros
     67           * ------------------------------------------------------------------------------------------------
     68           */
     69          
     70          /* POWER CONSERVATION DEFINITIONS
     71           * Sleep mode H/W definitions (enabled with POWER_SAVING compile option)
     72           */
     73          #define CC2530_PM0            0  /* PM0, Clock oscillators on, voltage regulator on */
     74          #define CC2530_PM1            1  /* PM1, 32.768 kHz oscillators on, voltage regulator on */
     75          #define CC2530_PM2            2  /* PM2, 32.768 kHz oscillators on, voltage regulator off */
     76          #define CC2530_PM3            3  /* PM3, All clock oscillators off, voltage regulator off */
     77          
     78          /* HAL power management mode is set according to the power management state. The default
     79           * setting is HAL_SLEEP_OFF. The actual value is tailored to different HW platform. Both
     80           * HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections will:
     81           *   1. turn off the system clock, and
     82           *   2. halt the MCU.
     83           * HAL_SLEEP_TIMER can be woken up by sleep timer interrupt, I/O interrupt and reset.
     84           * HAL_SLEEP_DEEP can be woken up by I/O interrupt and reset.
     85           */
     86          #define HAL_SLEEP_OFF         CC2530_PM0
     87          #define HAL_SLEEP_TIMER       CC2530_PM2
     88          #define HAL_SLEEP_DEEP        CC2530_PM3
     89          
     90          /* MAX_SLEEP_TIME calculation:
     91           *   Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
     92           *   Round it to 510 seconds or 510000 ms
     93           */
     94          #define MAX_SLEEP_TIME                   510000             /* maximum time to sleep allowed by ST */
     95          
     96          
     97          /* minimum time to sleep, this macro is to:
     98           * 1. avoid thrashing in-and-out of sleep with short OSAL timer (~2ms)
     99           * 2. define minimum safe sleep period
    100           */
    101          #if !defined (PM_MIN_SLEEP_TIME)
    102          #define PM_MIN_SLEEP_TIME                14                 /* default to minimum safe sleep time minimum CAP */
    103          #endif
    104          
    105          /* The PCON instruction must be 4-byte aligned. The following code may cause excessive power
    106           * consumption if not aligned. See linker file ".xcl" for actual placement.
    107           */
    108          #pragma location = "SLEEP_CODE"

   \                                 In  segment SLEEP_CODE, align 1, keep-with-next
    109          static void halSetSleepMode(void)
   \                     halSetSleepMode:
    110          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    111            PCON |= PCON_IDLE;
   \   000000   438701       ORL     0x87,#0x1
    112            asm("NOP");
   \   000003   00           NOP
    113          }
   \   000004   02....       LJMP    ?BRET
   \   000007                REQUIRE PCON
    114          
    115          /* This value is used to adjust the sleep timer compare value such that the sleep timer
    116           * compare takes into account the amount of processing time spent in function halSleep().
    117           * The first value is determined by measuring the number of sleep timer ticks it from
    118           * the beginning of the function to entering sleep mode.  The second value is determined
    119           * by measuring the number of sleep timer ticks from exit of sleep mode to the call to
    120           * osal_adjust_timers().
    121           */
    122          #define HAL_SLEEP_ADJ_TICKS   (7 + 10)
    123          
    124          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
    125          /* set CC2530 power mode; always use PM2 */
    126          #define HAL_SLEEP_SET_POWER_MODE(mode)       st( SLEEPCMD &= ~PMODE; /* clear mode bits */    \
    127                                                           SLEEPCMD |= mode;   /* set mode bits   */    \
    128                                                           while (!(STLOAD & LDRDY));                   \
    129                                                           {                                            \
    130                                                             halSetSleepMode();                         \
    131                                                           }                                            \
    132                                                         )
    133          #else
    134          /* Debug: don't set power mode, just block until sleep timer interrupt */
    135          #define HAL_SLEEP_SET_POWER_MODE(mode)      st( while(halSleepInt == FALSE); \
    136                                                          halSleepInt = FALSE; )
    137          #endif
    138          
    139          /* sleep and external interrupt port masks */
    140          #define STIE_BV                             BV(5)
    141          #define P0IE_BV                             BV(5)
    142          #define P1IE_BV                             BV(4)
    143          #define P2IE_BV                             BV(1)
    144          
    145          /* sleep timer interrupt control */
    146          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IEN0 |= STIE_BV;)     /* enable sleep timer interrupt */
    147          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IEN0 &= ~STIE_BV;)    /* disable sleep timer interrupt */
    148          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(IRCON &= ~0x80;)      /* clear sleep interrupt flag */
    149          
    150          /* backup interrupt enable registers before sleep */
    151          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2) st(ien0  = IEN0;    /* backup IEN0 register */ \
    152                                                                       ien1  = IEN1;    /* backup IEN1 register */ \
    153                                                                       ien2  = IEN2;    /* backup IEN2 register */ \
    154                                                                       IEN0 &= STIE_BV; /* disable IEN0 except STIE */ \
    155                                                                       IEN1 &= P0IE_BV; /* disable IEN1 except P0IE */ \
    156                                                                       IEN2 &= (P1IE_BV|P2IE_BV);) /* disable IEN2 except P1IE, P2IE */
    157          
    158          /* restore interrupt enable registers before sleep */
    159          #define HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2) st(IEN0 = ien0;   /* restore IEN0 register */ \
    160                                                            IEN1 = ien1;   /* restore IEN1 register */ \
    161                                                            IEN2 = ien2;)  /* restore IEN2 register */
    162          
    163          /* convert msec to 320 usec units with round */
    164          #define HAL_SLEEP_MS_TO_320US(ms)           (((((uint32) (ms)) * 100) + 31) / 32)
    165          
    166          /* for optimized indexing of uint32's */
    167          #if HAL_MCU_LITTLE_ENDIAN()
    168          #define UINT32_NDX0   0
    169          #define UINT32_NDX1   1
    170          #define UINT32_NDX2   2
    171          #define UINT32_NDX3   3
    172          #else
    173          #define UINT32_NDX0   3
    174          #define UINT32_NDX1   2
    175          #define UINT32_NDX2   1
    176          #define UINT32_NDX3   0
    177          #endif
    178          
    179          /* ------------------------------------------------------------------------------------------------
    180           *                                        Local Variables
    181           * ------------------------------------------------------------------------------------------------
    182           */
    183          
    184          /* HAL power management mode is set according to the power management state.
    185           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    186          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
   \                     halPwrMgtMode:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    187          
    188          /* stores the sleep timer count upon entering sleep */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    189          static uint32 halSleepTimerStart;
   \                     halSleepTimerStart:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    190          
    191          /* stores the accumulated sleep time */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    192          static uint32 halAccumulatedSleepTime;
   \                     halAccumulatedSleepTime:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    193          
    194          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    195          static bool halSleepInt = FALSE;
    196          #endif
    197          
    198          /* ------------------------------------------------------------------------------------------------
    199           *                                      Function Prototypes
    200           * ------------------------------------------------------------------------------------------------
    201           */
    202          
    203          void halSleepSetTimer(uint32 timeout);
    204          uint32 HalTimerElapsed( void );
    205          
    206          /**************************************************************************************************
    207           * @fn          halSleep
    208           *
    209           * @brief       This function is called from the OSAL task loop using and existing OSAL
    210           *              interface.  It sets the low power mode of the MAC and the CC2530.
    211           *
    212           * input parameters
    213           *
    214           * @param       osal_timeout - Next OSAL timer timeout.
    215           *
    216           * output parameters
    217           *
    218           * None.
    219           *
    220           * @return      None.
    221           **************************************************************************************************
    222           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    223          void halSleep( uint16 osal_timeout )
   \                     halSleep:
    224          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    225            uint32        timeout;
    226            uint32        macTimeout = 0;
    227          
    228            halAccumulatedSleepTime = 0;
   \   00000A   90....       MOV     DPTR,#__Constant_0
   \   00000D   78..         MOV     R0,#?V0 + 0
   \   00000F   12....       LCALL   ?L_MOV_X
   \   000012   90....       MOV     DPTR,#halAccumulatedSleepTime
   \   000015   78..         MOV     R0,#?V0 + 0
   \   000017   12....       LCALL   ?L_MOV_TO_X
    229          
    230            /* get next OSAL timer expiration converted to 320 usec units */
    231            timeout = HAL_SLEEP_MS_TO_320US(osal_timeout);
   \   00001A   8A..         MOV     ?V0 + 0,R2
   \   00001C   8B..         MOV     ?V0 + 1,R3
   \   00001E   75..00       MOV     ?V0 + 2,#0x0
   \   000021   75..00       MOV     ?V0 + 3,#0x0
   \   000024   90....       MOV     DPTR,#__Constant_64
   \   000027   78..         MOV     R0,#?V0 + 4
   \   000029   12....       LCALL   ?L_MOV_X
   \   00002C   78..         MOV     R0,#?V0 + 0
   \   00002E   79..         MOV     R1,#?V0 + 4
   \   000030   12....       LCALL   ?L_MUL
   \   000033   90....       MOV     DPTR,#__Constant_1f
   \   000036   78..         MOV     R0,#?V0 + 0
   \   000038   12....       LCALL   ?L_ADD_X
   \   00003B   7405         MOV     A,#0x5
   \   00003D   78..         MOV     R0,#?V0 + 0
   \   00003F   12....       LCALL   ?UL_SHR
   \   000042   85..82       MOV     DPL,?XSP + 0
   \   000045   85..83       MOV     DPH,?XSP + 1
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?L_MOV_TO_X
    232            if (timeout == 0)
   \   00004D   85..82       MOV     DPL,?XSP + 0
   \   000050   85..83       MOV     DPH,?XSP + 1
   \   000053   C082         PUSH    DPL
   \   000055   C083         PUSH    DPH
   \   000057   90....       MOV     DPTR,#__Constant_0
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?L_MOV_X
   \   00005F   D083         POP     DPH
   \   000061   D082         POP     DPL
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_EQ_X
   \   000068   7033         JNZ     ??halSleep_0
    233            {
    234              timeout = MAC_PwrNextTimeout();
   \   00006A                ; Setup parameters for call to function MAC_PwrNextTimeout
   \   00006A   12....       LCALL   ?Subroutine0 & 0xFFFF
    235            }
   \                     ??CrossCallReturnLabel_0:
   \   00006D   85..82       MOV     DPL,?XSP + 0
   \   000070   85..83       MOV     DPH,?XSP + 1
   \   000073   78..         MOV     R0,#?V0 + 0
   \   000075   12....       LCALL   ?L_MOV_TO_X
    236            else
    237            {
    238              /* get next MAC timer expiration */
    239              macTimeout = MAC_PwrNextTimeout();
    240          
    241              /* get lesser of two timeouts */
    242              if ((macTimeout != 0) && (macTimeout < timeout))
    243              {
    244                timeout = macTimeout;
    245              }
    246            }
    247          
    248            /* HAL_SLEEP_PM2 is entered only if the timeout is zero and
    249             * the device is a stimulated device.
    250             */
    251            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
   \   000078   85..82       MOV     DPL,?XSP + 0
   \   00007B   85..83       MOV     DPH,?XSP + 1
   \   00007E   C082         PUSH    DPL
   \   000080   C083         PUSH    DPH
   \   000082   90....       MOV     DPTR,#__Constant_0
   \   000085   78..         MOV     R0,#?V0 + 0
   \   000087   12....       LCALL   ?L_MOV_X
   \   00008A   D083         POP     DPH
   \   00008C   D082         POP     DPL
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   12....       LCALL   ?L_EQ_X
   \   000093   7034         JNZ     ??halSleep_1
   \   000095   7403         MOV     A,#0x3
   \   000097   90....       MOV     DPTR,#halPwrMgtMode
   \   00009A   F0           MOVX    @DPTR,A
   \   00009B   806B         SJMP    ??halSleep_2
   \                     ??halSleep_0:
   \   00009D                ; Setup parameters for call to function MAC_PwrNextTimeout
   \   00009D   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000A0   90....       MOV     DPTR,#__Constant_0
   \   0000A3   78..         MOV     R0,#?V0 + 0
   \   0000A5   12....       LCALL   ?L_EQ_X
   \   0000A8   601F         JZ      ??halSleep_1
   \   0000AA   85..82       MOV     DPL,?XSP + 0
   \   0000AD   85..83       MOV     DPH,?XSP + 1
   \   0000B0   78..         MOV     R0,#?V0 + 4
   \   0000B2   12....       LCALL   ?L_MOV_X
   \   0000B5   78..         MOV     R0,#?V0 + 4
   \   0000B7   79..         MOV     R1,#?V0 + 0
   \   0000B9   12....       LCALL   ?UL_GT
   \   0000BC   500B         JNC     ??halSleep_1
   \   0000BE   85..82       MOV     DPL,?XSP + 0
   \   0000C1   85..83       MOV     DPH,?XSP + 1
   \   0000C4   78..         MOV     R0,#?V0 + 0
   \   0000C6   12....       LCALL   ?L_MOV_TO_X
   \                     ??halSleep_1:
   \   0000C9   7402         MOV     A,#0x2
   \   0000CB   90....       MOV     DPTR,#halPwrMgtMode
   \   0000CE   12....       LCALL   ?Subroutine1 & 0xFFFF
    252          
    253            /* DEEP sleep can only be entered when zgPollRate == 0.
    254             * This is to eliminate any possibility of entering PM3 between
    255             * two network timers.
    256             */
    257          #if !defined (RTR_NWK) && defined (NWK_AUTO_POLL)
    258            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    259                (timeout == 0 && zgPollRate == 0))
   \                     ??CrossCallReturnLabel_2:
   \   0000D1   C082         PUSH    DPL
   \   0000D3   C083         PUSH    DPH
   \   0000D5   90....       MOV     DPTR,#__Constant_2d
   \   0000D8   78..         MOV     R0,#?V0 + 0
   \   0000DA   12....       LCALL   ?L_MOV_X
   \   0000DD   D083         POP     DPH
   \   0000DF   D082         POP     DPL
   \   0000E1   78..         MOV     R0,#?V0 + 0
   \   0000E3   12....       LCALL   ?UL_GT_X
   \   0000E6   502D         JNC     ??halSleep_3
   \   0000E8   85..82       MOV     DPL,?XSP + 0
   \   0000EB   85..83       MOV     DPH,?XSP + 1
   \   0000EE   C082         PUSH    DPL
   \   0000F0   C083         PUSH    DPH
   \   0000F2   90....       MOV     DPTR,#__Constant_0
   \   0000F5   78..         MOV     R0,#?V0 + 0
   \   0000F7   12....       LCALL   ?L_MOV_X
   \   0000FA   D083         POP     DPH
   \   0000FC   D082         POP     DPL
   \   0000FE   78..         MOV     R0,#?V0 + 0
   \   000100   12....       LCALL   ?L_EQ_X
   \   000103   6003         JZ      $+5
   \   000105   02....       LJMP    ??halSleep_4 & 0xFFFF
   \                     ??halSleep_2:
   \   000108   90....       MOV     DPTR,#zgPollRate
   \   00010B   E0           MOVX    A,@DPTR
   \   00010C   7002         JNZ     ??halSleep_5
   \   00010E   A3           INC     DPTR
   \   00010F   E0           MOVX    A,@DPTR
   \                     ??halSleep_5:
   \   000110   6003         JZ      $+5
   \   000112   02....       LJMP    ??halSleep_4 & 0xFFFF
    260          #else
    261            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    262                (timeout == 0))
    263          #endif
    264            {
    265              halIntState_t ien0, ien1, ien2;
    266          
    267              HAL_ASSERT(HAL_INTERRUPTS_ARE_ENABLED());
   \                     ??halSleep_3:
   \   000115   A2AF         MOV     C,0xa8.7
   \   000117   4003         JC      ??halSleep_6
   \   000119                ; Setup parameters for call to function halAssertHandler
   \   000119   12....       LCALL   ??halAssertHandler?relay
    268              HAL_DISABLE_INTERRUPTS();
   \                     ??halSleep_6:
   \   00011C   C2AF         CLR     0xa8.7
    269          
    270              /* always use "deep sleep" to turn off radio VREG on CC2530 */
    271              if (MAC_PwrOffReq(MAC_PWR_SLEEP_DEEP) == MAC_SUCCESS)
   \   00011E                ; Setup parameters for call to function MAC_PwrOffReq
   \   00011E   7902         MOV     R1,#0x2
   \   000120   12....       LCALL   ??MAC_PwrOffReq?relay
   \   000123   E9           MOV     A,R1
   \   000124   6003         JZ      $+5
   \   000126   02....       LJMP    ??halSleep_7 & 0xFFFF
    272              {
    273                while ( (HAL_SLEEP_MS_TO_320US(halAccumulatedSleepTime) < timeout) || (timeout == 0) )
   \                     ??halSleep_8:
   \   000129   90....       MOV     DPTR,#halAccumulatedSleepTime
   \   00012C   78..         MOV     R0,#?V0 + 0
   \   00012E   12....       LCALL   ?L_MOV_X
   \   000131   90....       MOV     DPTR,#__Constant_64
   \   000134   78..         MOV     R0,#?V0 + 4
   \   000136   12....       LCALL   ?L_MOV_X
   \   000139   78..         MOV     R0,#?V0 + 0
   \   00013B   79..         MOV     R1,#?V0 + 4
   \   00013D   12....       LCALL   ?L_MUL
   \   000140   90....       MOV     DPTR,#__Constant_1f
   \   000143   78..         MOV     R0,#?V0 + 0
   \   000145   12....       LCALL   ?L_ADD_X
   \   000148   7405         MOV     A,#0x5
   \   00014A   78..         MOV     R0,#?V0 + 0
   \   00014C   12....       LCALL   ?UL_SHR
   \   00014F   85..82       MOV     DPL,?XSP + 0
   \   000152   85..83       MOV     DPH,?XSP + 1
   \   000155   78..         MOV     R0,#?V0 + 4
   \   000157   12....       LCALL   ?L_MOV_X
   \   00015A   78..         MOV     R0,#?V0 + 4
   \   00015C   79..         MOV     R1,#?V0 + 0
   \   00015E   12....       LCALL   ?UL_GT
   \   000161   4020         JC      ??halSleep_9
   \   000163   85..82       MOV     DPL,?XSP + 0
   \   000166   85..83       MOV     DPH,?XSP + 1
   \   000169   C082         PUSH    DPL
   \   00016B   C083         PUSH    DPH
   \   00016D   90....       MOV     DPTR,#__Constant_0
   \   000170   78..         MOV     R0,#?V0 + 0
   \   000172   12....       LCALL   ?L_MOV_X
   \   000175   D083         POP     DPH
   \   000177   D082         POP     DPL
   \   000179   78..         MOV     R0,#?V0 + 0
   \   00017B   12....       LCALL   ?L_EQ_X
   \   00017E   6003         JZ      $+5
   \   000180   02....       LJMP    ??halSleep_10 & 0xFFFF
    274                {
    275                  /* get peripherals ready for sleep */
    276                  HalKeyEnterSleep();
   \                     ??halSleep_9:
   \   000183                ; Setup parameters for call to function HalKeyEnterSleep
   \   000183   12....       LCALL   ??HalKeyEnterSleep?relay
    277          
    278          #ifdef HAL_SLEEP_DEBUG_LED
    279                  HAL_TURN_OFF_LED3();
    280          #else
    281                  /* use this to turn LEDs off during sleep */
    282                  HalLedEnterSleep();
   \   000186                ; Setup parameters for call to function HalLedEnterSleep
   \   000186   12....       LCALL   ??HalLedEnterSleep?relay
    283          #endif
    284          
    285                  /* enable sleep timer interrupt */
    286                  if (timeout != 0)
   \   000189   85..82       MOV     DPL,?XSP + 0
   \   00018C   85..83       MOV     DPH,?XSP + 1
   \   00018F   C082         PUSH    DPL
   \   000191   C083         PUSH    DPH
   \   000193   90....       MOV     DPTR,#__Constant_0
   \   000196   78..         MOV     R0,#?V0 + 0
   \   000198   12....       LCALL   ?L_MOV_X
   \   00019B   D083         POP     DPH
   \   00019D   D082         POP     DPL
   \   00019F   78..         MOV     R0,#?V0 + 0
   \   0001A1   12....       LCALL   ?L_EQ_X
   \   0001A4   604F         JZ      ??halSleep_11
    287                  {
    288                    if (timeout > HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ))
   \   0001A6   85..82       MOV     DPL,?XSP + 0
   \   0001A9   85..83       MOV     DPH,?XSP + 1
   \   0001AC   C082         PUSH    DPL
   \   0001AE   C083         PUSH    DPH
   \   0001B0   90....       MOV     DPTR,#__Constant_185197
   \   0001B3   78..         MOV     R0,#?V0 + 0
   \   0001B5   12....       LCALL   ?L_MOV_X
   \   0001B8   D083         POP     DPH
   \   0001BA   D082         POP     DPL
   \   0001BC   78..         MOV     R0,#?V0 + 0
   \   0001BE   12....       LCALL   ?UL_GT_X
   \   0001C1   4018         JC      ??halSleep_12
    289                    {
    290                      timeout -= HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME );
   \   0001C3   90....       MOV     DPTR,#__Constant_ffe7ae6a
   \   0001C6   78..         MOV     R0,#?V0 + 0
   \   0001C8   12....       LCALL   ?L_MOV_X
   \   0001CB   85..82       MOV     DPL,?XSP + 0
   \   0001CE   85..83       MOV     DPH,?XSP + 1
   \   0001D1   78..         MOV     R0,#?V0 + 0
   \   0001D3   12....       LCALL   ?L_ADD_TO_X
    291                      halSleepSetTimer(HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ));
   \   0001D6                ; Setup parameters for call to function halSleepSetTimer
   \   0001D6   90....       MOV     DPTR,#__Constant_185196
   \   0001D9   8006         SJMP    ??halSleep_13
    292                    }
    293                    else
    294                    {
    295                      /* set sleep timer */
    296                      halSleepSetTimer(timeout);
   \                     ??halSleep_12:
   \   0001DB                ; Setup parameters for call to function halSleepSetTimer
   \   0001DB   85..82       MOV     DPL,?XSP + 0
   \   0001DE   85..83       MOV     DPH,?XSP + 1
   \                     ??halSleep_13:
   \   0001E1   78..         MOV     R0,#?V0 + 0
   \   0001E3   12....       LCALL   ?L_MOV_X
   \   0001E6   AA..         MOV     R2,?V0 + 0
   \   0001E8   AB..         MOV     R3,?V0 + 1
   \   0001EA   AC..         MOV     R4,?V0 + 2
   \   0001EC   AD..         MOV     R5,?V0 + 3
   \   0001EE   12....       LCALL   ??halSleepSetTimer?relay
    297                    }
    298          
    299                    /* set up sleep timer interrupt */
    300                    HAL_SLEEP_TIMER_CLEAR_INT();
   \   0001F1   C2C7         CLR     0xc0.7
    301                    HAL_SLEEP_TIMER_ENABLE_INT();
   \   0001F3   D2AD         SETB    0xa8.5
    302                  }
    303          
    304          #ifdef HAL_SLEEP_DEBUG_LED
    305                  if (halPwrMgtMode == CC2530_PM1)
    306                  {
    307                    HAL_TURN_ON_LED1();
    308                  }
    309                  else
    310                  {
    311                    HAL_TURN_OFF_LED1();
    312                  }
    313          #endif
    314          
    315                  /* save interrupt enable registers and disable all interrupts */
    316                  HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2);
   \                     ??halSleep_11:
   \   0001F5   E5A8         MOV     A,0xa8
   \   0001F7   FE           MOV     R6,A
   \   0001F8   E5B8         MOV     A,0xb8
   \   0001FA   FF           MOV     R7,A
   \   0001FB   E59A         MOV     A,0x9a
   \   0001FD   F5..         MOV     ?V0 + 0,A
   \   0001FF   53A820       ANL     0xa8,#0x20
   \   000202   E5A8         MOV     A,0xa8
   \   000204   53B820       ANL     0xb8,#0x20
   \   000207   E5B8         MOV     A,0xb8
   \   000209   539A12       ANL     0x9a,#0x12
   \   00020C   E59A         MOV     A,0x9a
    317                  HAL_ENABLE_INTERRUPTS();
   \   00020E   D2AF         SETB    0xa8.7
    318          
    319                  /* set CC2530 power mode, interrupt is disabled after this function */
    320                  HAL_SLEEP_SET_POWER_MODE(halPwrMgtMode);
   \   000210   53BEFC       ANL     0xbe,#0xfc
   \   000213   E5BE         MOV     A,0xbe
   \   000215   90....       MOV     DPTR,#halPwrMgtMode
   \   000218   E0           MOVX    A,@DPTR
   \   000219   45BE         ORL     A,0xbe
   \   00021B   F5BE         MOV     0xbe,A
   \                     ??halSleep_14:
   \   00021D   E5AD         MOV     A,0xad
   \   00021F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000221   50FA         JNC     ??halSleep_14
   \   000223                ; Setup parameters for call to function halSetSleepMode
   \   000223   12....       LCALL   ??halSetSleepMode?relay
    321                  HAL_DISABLE_INTERRUPTS();
   \   000226   C2AF         CLR     0xa8.7
    322          
    323                  /* restore interrupt enable registers */
    324                  HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2);
   \   000228   8EA8         MOV     0xa8,R6
   \   00022A   8FB8         MOV     0xb8,R7
   \   00022C   85..9A       MOV     0x9a,?V0 + 0
    325          
    326                  /* disable sleep timer interrupt */
    327                  HAL_SLEEP_TIMER_DISABLE_INT();
   \   00022F   C2AD         CLR     0xa8.5
    328          
    329                  /* Calculate timer elasped */
    330                  halAccumulatedSleepTime += (HalTimerElapsed() / TICK_COUNT);
   \   000231                ; Setup parameters for call to function HalTimerElapsed
   \   000231   12....       LCALL   ??HalTimerElapsed?relay
   \   000234   8A..         MOV     ?V0 + 0,R2
   \   000236   8B..         MOV     ?V0 + 1,R3
   \   000238   8C..         MOV     ?V0 + 2,R4
   \   00023A   8D..         MOV     ?V0 + 3,R5
   \   00023C   90....       MOV     DPTR,#halAccumulatedSleepTime
   \   00023F   78..         MOV     R0,#?V0 + 0
   \   000241   12....       LCALL   ?L_ADD_TO_X
    331          
    332                  /* deduct the sleep time for the next iteration */
    333                  if ( osal_timeout > halAccumulatedSleepTime)
    334                  {
    335                    osal_timeout -= halAccumulatedSleepTime;
    336                  }
    337          
    338          #ifdef HAL_SLEEP_DEBUG_LED
    339                  HAL_TURN_ON_LED3();
    340          #else
    341                  /* use this to turn LEDs back on after sleep */
    342                  HalLedExitSleep();
   \   000244                ; Setup parameters for call to function HalLedExitSleep
   \   000244   12....       LCALL   ??HalLedExitSleep?relay
    343          #endif
    344          
    345                  /* handle peripherals; exit loop if key presses */
    346                  if ( HalKeyExitSleep() )
   \   000247                ; Setup parameters for call to function HalKeyExitSleep
   \   000247   12....       LCALL   ??HalKeyExitSleep?relay
   \   00024A   E9           MOV     A,R1
   \   00024B   7020         JNZ     ??halSleep_10
    347                  {
    348                    break;
    349                  }
    350          
    351                  /* exit loop if no timer active */
    352                  if ( timeout == 0 ) break;
   \   00024D   85..82       MOV     DPL,?XSP + 0
   \   000250   85..83       MOV     DPH,?XSP + 1
   \   000253   C082         PUSH    DPL
   \   000255   C083         PUSH    DPH
   \   000257   90....       MOV     DPTR,#__Constant_0
   \   00025A   78..         MOV     R0,#?V0 + 0
   \   00025C   12....       LCALL   ?L_MOV_X
   \   00025F   D083         POP     DPH
   \   000261   D082         POP     DPL
   \   000263   78..         MOV     R0,#?V0 + 0
   \   000265   12....       LCALL   ?L_EQ_X
   \   000268   6003         JZ      $+5
   \   00026A   02....       LJMP    ??halSleep_8 & 0xFFFF
    353                }
    354          
    355                /* power on the MAC; blocks until completion */
    356                MAC_PwrOnReq();
   \                     ??halSleep_10:
   \   00026D                ; Setup parameters for call to function MAC_PwrOnReq
   \   00026D   12....       LCALL   ??MAC_PwrOnReq?relay
    357          
    358              }
    359          
    360              HAL_ENABLE_INTERRUPTS();
   \                     ??halSleep_7:
   \   000270   D2AF         SETB    0xa8.7
    361            }
    362          }
   \                     ??halSleep_4:
   \   000272                REQUIRE ?Subroutine2
   \   000272                REQUIRE IEN2
   \   000272                REQUIRE _A_IEN0
   \   000272                REQUIRE STLOAD
   \   000272                REQUIRE _A_IEN1
   \   000272                REQUIRE SLEEPCMD
   \   000272                REQUIRE _A_IRCON
   \   000272                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7404         MOV     A,#0x4
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005   7F08         MOV     R7,#0x8
   \   000007   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ??MAC_PwrNextTimeout?relay
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   8C..         MOV     ?V0 + 2,R4
   \   000009   8D..         MOV     ?V0 + 3,R5
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET
    363          
    364          /**************************************************************************************************
    365           * @fn          halSleepSetTimer
    366           *
    367           * @brief       This function sets the CC2530 sleep timer compare value.  First it reads and
    368           *              stores the value of the sleep timer; this value is used later to update OSAL
    369           *              timers.  Then the timeout value is converted from 320 usec units to 32 kHz
    370           *              period units and the compare value is set to the timeout.
    371           *
    372           * input parameters
    373           *
    374           * @param       timeout - Timeout value in 320 usec units.  The sleep timer compare is set to
    375           *                        this value.
    376           *
    377           * output parameters
    378           *
    379           * None.
    380           *
    381           * @return      None.
    382           **************************************************************************************************
    383           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    384          void halSleepSetTimer(uint32 timeout)
   \                     halSleepSetTimer:
    385          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
    386            uint32 ticks;
    387          
    388            /* read the sleep timer; ST0 must be read first */
    389            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
   \   000012   E595         MOV     A,0x95
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   F0           MOVX    @DPTR,A
    390            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
   \   00001B   E596         MOV     A,0x96
   \   00001D   C0E0         PUSH    A
   \   00001F   7401         MOV     A,#0x1
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   D0E0         POP     A
   \   000026   F0           MOVX    @DPTR,A
    391            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
   \   000027   E597         MOV     A,0x97
   \   000029   C0E0         PUSH    A
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   D0E0         POP     A
   \   000032   F0           MOVX    @DPTR,A
    392            ((uint8 *) &ticks)[UINT32_NDX3] = 0;
   \   000033   7403         MOV     A,#0x3
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E4           CLR     A
   \   000039   12....       LCALL   ?Subroutine1 & 0xFFFF
    393          
    394            /* store value for later */
    395            halSleepTimerStart = ticks;
   \                     ??CrossCallReturnLabel_3:
   \   00003C   78..         MOV     R0,#?V0 + 4
   \   00003E   12....       LCALL   ?L_MOV_X
   \   000041   90....       MOV     DPTR,#halSleepTimerStart
   \   000044   78..         MOV     R0,#?V0 + 4
   \   000046   12....       LCALL   ?L_MOV_TO_X
    396          
    397            /* Compute sleep timer compare value.  The ratio of 32 kHz ticks to 320 usec ticks
    398             * is 32768/3125 = 10.48576.  This is nearly 671/64 = 10.484375.
    399             */
    400            ticks += (timeout * 671) / 64;
    401          
    402            /* subtract the processing time spent in function halSleep() */
    403            ticks -= HAL_SLEEP_ADJ_TICKS;
   \   000049   90....       MOV     DPTR,#__Constant_29f
   \   00004C   78..         MOV     R0,#?V0 + 4
   \   00004E   12....       LCALL   ?L_MOV_X
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   79..         MOV     R1,#?V0 + 4
   \   000055   12....       LCALL   ?L_MUL
   \   000058   7406         MOV     A,#0x6
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?UL_SHR
   \   00005F   90....       MOV     DPTR,#__Constant_ffffffef
   \   000062   78..         MOV     R0,#?V0 + 0
   \   000064   12....       LCALL   ?L_ADD_X
   \   000067   85..82       MOV     DPL,?XSP + 0
   \   00006A   85..83       MOV     DPH,?XSP + 1
   \   00006D   78..         MOV     R0,#?V0 + 0
   \   00006F   12....       LCALL   ?L_ADD_TO_X
    404          
    405            /* set sleep timer compare; ST0 must be written last */
    406            ST2 = ((uint8 *) &ticks)[UINT32_NDX2];
   \   000072   7402         MOV     A,#0x2
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F597         MOV     0x97,A
    407            ST1 = ((uint8 *) &ticks)[UINT32_NDX1];
   \   00007A   7401         MOV     A,#0x1
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F596         MOV     0x96,A
    408            ST0 = ((uint8 *) &ticks)[UINT32_NDX0];
   \   000082   85..82       MOV     DPL,?XSP + 0
   \   000085   85..83       MOV     DPH,?XSP + 1
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F595         MOV     0x95,A
    409          }
   \   00008B   02....       LJMP    ?Subroutine2 & 0xFFFF
   \   00008E                REQUIRE ST0
   \   00008E                REQUIRE ST1
   \   00008E                REQUIRE ST2
    410          
    411          /**************************************************************************************************
    412           * @fn          TimerElapsed
    413           *
    414           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    415           *
    416           * input parameters
    417           *
    418           * @param       None.
    419           *
    420           * output parameters
    421           *
    422           * None.
    423           *
    424           * @return      Number of timer ticks elapsed during sleep.
    425           **************************************************************************************************
    426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    427          uint32 TimerElapsed( void )
   \                     TimerElapsed:
    428          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    429            return ( halAccumulatedSleepTime );
   \   000005   90....       MOV     DPTR,#halAccumulatedSleepTime
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   12....       LCALL   ?L_MOV_X
   \   00000D   AA..         MOV     R2,?V0 + 0
   \   00000F   AB..         MOV     R3,?V0 + 1
   \   000011   AC..         MOV     R4,?V0 + 2
   \   000013   AD..         MOV     R5,?V0 + 3
   \   000015   7F04         MOV     R7,#0x4
   \   000017   02....       LJMP    ?BANKED_LEAVE_XDATA
    430          }
    431          
    432          /**************************************************************************************************
    433           * @fn          HalTimerElapsed
    434           *
    435           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.  This function
    436           *              relies on OSAL macro TICK_COUNT to be set to 1; then ticks are calculated in
    437           *              units of msec.
    438           *
    439           * input parameters
    440           *
    441           * @param       None.
    442           *
    443           * output parameters
    444           *
    445           * None.
    446           *
    447           * @return      Number of timer ticks elapsed during sleep.
    448           **************************************************************************************************
    449           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    450          uint32 HalTimerElapsed( void )
   \                     HalTimerElapsed:
    451          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    452            uint32 ticks;
    453          
    454            /* read the sleep timer; ST0 must be read first */
    455            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
   \   00000A   E595         MOV     A,0x95
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    456            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
   \   000013   E596         MOV     A,0x96
   \   000015   C0E0         PUSH    A
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   D0E0         POP     A
   \   00001E   F0           MOVX    @DPTR,A
    457            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
   \   00001F   E597         MOV     A,0x97
   \   000021   C0E0         PUSH    A
   \   000023   7402         MOV     A,#0x2
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   D0E0         POP     A
   \   00002A   F0           MOVX    @DPTR,A
    458          
    459            /* set bit 24 to handle wraparound */
    460            ((uint8 *) &ticks)[UINT32_NDX3] = 0x01;
   \   00002B   7403         MOV     A,#0x3
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   7401         MOV     A,#0x1
   \   000032   12....       LCALL   ?Subroutine1 & 0xFFFF
    461          
    462            /* calculate elapsed time */
    463            ticks -= halSleepTimerStart;
    464          
    465            /* add back the processing time spent in function halSleep() */
    466            ticks += HAL_SLEEP_ADJ_TICKS;
    467          
    468            /* mask off excess if no wraparound */
    469            ticks &= 0x00FFFFFF;
    470          
    471            /* Convert elapsed time in milliseconds with round.  1000/32768 = 125/4096 */
    472            return ( ((ticks * 125) + 4095) / 4096 );
   \                     ??CrossCallReturnLabel_4:
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?L_MOV_X
   \   00003A   90....       MOV     DPTR,#halSleepTimerStart
   \   00003D   78..         MOV     R0,#?V0 + 0
   \   00003F   12....       LCALL   ?L_SUB_X
   \   000042   90....       MOV     DPTR,#__Constant_11
   \   000045   78..         MOV     R0,#?V0 + 0
   \   000047   12....       LCALL   ?L_ADD_X
   \   00004A   90....       MOV     DPTR,#__Constant_ffffff
   \   00004D   78..         MOV     R0,#?V0 + 0
   \   00004F   12....       LCALL   ?L_AND_X
   \   000052   90....       MOV     DPTR,#__Constant_7d
   \   000055   78..         MOV     R0,#?V0 + 4
   \   000057   12....       LCALL   ?L_MOV_X
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   79..         MOV     R1,#?V0 + 4
   \   00005E   12....       LCALL   ?L_MUL
   \   000061   90....       MOV     DPTR,#__Constant_fff
   \   000064   78..         MOV     R0,#?V0 + 0
   \   000066   12....       LCALL   ?L_ADD_X
   \   000069   740C         MOV     A,#0xc
   \   00006B   78..         MOV     R0,#?V0 + 0
   \   00006D   12....       LCALL   ?UL_SHR
   \   000070   AA..         MOV     R2,?V0 + 0
   \   000072   AB..         MOV     R3,?V0 + 1
   \   000074   AC..         MOV     R4,?V0 + 2
   \   000076   FD           MOV     R5,A
   \   000077   02....       LJMP    ?Subroutine2 & 0xFFFF
   \   00007A                REQUIRE ST0
   \   00007A                REQUIRE ST1
   \   00007A                REQUIRE ST2
    473          }
    474          
    475          /**************************************************************************************************
    476           * @fn          halSleepWait
    477           *
    478           * @brief       Perform a blocking wait.
    479           *
    480           * input parameters
    481           *
    482           * @param       duration - Duration of wait in microseconds.
    483           *
    484           * output parameters
    485           *
    486           * None.
    487           *
    488           * @return      None.
    489           **************************************************************************************************
    490           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    491          void halSleepWait(uint16 duration)
   \                     halSleepWait:
    492          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8008         SJMP    ??halSleepWait_0
    493            while (duration--)
    494            {
    495              asm("NOP");
   \                     ??halSleepWait_1:
   \   000002   00           NOP
    496              asm("NOP");
   \   000003   00           NOP
    497              asm("NOP");
   \   000004   00           NOP
    498              asm("NOP");
   \   000005   00           NOP
    499              asm("NOP");
   \   000006   00           NOP
    500              asm("NOP");
   \   000007   00           NOP
    501              asm("NOP");
   \   000008   00           NOP
    502              asm("NOP");
   \   000009   00           NOP
    503            }
   \                     ??halSleepWait_0:
   \   00000A   EA           MOV     A,R2
   \   00000B   F8           MOV     R0,A
   \   00000C   EB           MOV     A,R3
   \   00000D   F9           MOV     R1,A
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   28           ADD     A,R0
   \   000011   1A           DEC     R2
   \   000012   74FF         MOV     A,#-0x1
   \   000014   39           ADDC    A,R1
   \   000015   FB           MOV     R3,A
   \   000016   E8           MOV     A,R0
   \   000017   7001         JNZ     ??halSleepWait_2
   \   000019   E9           MOV     A,R1
   \                     ??halSleepWait_2:
   \   00001A   70E6         JNZ     ??halSleepWait_1
    504          }
   \   00001C   02....       LJMP    ?BRET
    505          
    506          /**************************************************************************************************
    507           * @fn          halRestoreSleepLevel
    508           *
    509           * @brief       Restore the deepest timer sleep level.
    510           *
    511           * input parameters
    512           *
    513           * @param       None
    514           *
    515           * output parameters
    516           *
    517           *              None.
    518           *
    519           * @return      None.
    520           **************************************************************************************************
    521           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    522          void halRestoreSleepLevel( void )
   \                     halRestoreSleepLevel:
    523          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    524            /* Stubs */
    525          }
   \   000000   02....       LJMP    ?BRET
    526          
    527          /**************************************************************************************************
    528           * @fn          halSleepTimerIsr
    529           *
    530           * @brief       Sleep timer ISR.
    531           *
    532           * input parameters
    533           *
    534           * None.
    535           *
    536           * output parameters
    537           *
    538           * None.
    539           *
    540           * @return      None.
    541           **************************************************************************************************
    542           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    543          HAL_ISR_FUNCTION(halSleepTimerIsr, ST_VECTOR)
   \                     halSleepTimerIsr:
    544          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    545            HAL_SLEEP_TIMER_CLEAR_INT();
   \   000007   C2C7         CLR     0xc0.7
    546            CLEAR_SLEEP_MODE();
   \   000009   53BEFC       ANL     0xbe,#0xfc
   \   00000C   E5BE         MOV     A,0xbe
    547          
    548            /* CC2530 chip bug workaround */
    549            macMcuTimer2OverflowWorkaround();
   \   00000E                ; Setup parameters for call to function macMcuTimer2OverflowWorkaround
   \   00000E   12....       LCALL   ??macMcuTimer2OverflowWorkaround?relay
    550          
    551          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    552            halSleepInt = TRUE;
    553          #endif
    554          }
   \   000011   7F01         MOV     R7,#0x1
   \   000013   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000016                REQUIRE SLEEPCMD
   \   000016                REQUIRE _A_IRCON

   \                                 In  segment INTVEC, offset 0x2b, root
   \                     `??halSleepTimerIsr??INTVEC 43`:
   \   00002B   02....       LJMP       (halSleepTimerIsr)

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_64:
   \   000000   64000000     DD 100

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1f:
   \   000000   1F000000     DD 31

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2d:
   \   000000   2D000000     DD 45

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_185197:
   \   000000   97511800     DD 1593751

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffe7ae6a:
   \   000000   6AAEE7FF     DD 4293373546

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_185196:
   \   000000   96511800     DD 1593750

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_29f:
   \   000000   9F020000     DD 671

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffffef:
   \   000000   EFFFFFFF     DD 4294967279

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_11:
   \   000000   11000000     DD 17

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffff:
   \   000000   FFFFFF00     DD 16777215

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_7d:
   \   000000   7D000000     DD 125

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_fff:
   \   000000   FF0F0000     DD 4095

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSetSleepMode?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSetSleepMode

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleepSetTimer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleepSetTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??TimerElapsed?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    TimerElapsed

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalTimerElapsed?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalTimerElapsed

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleepWait?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleepWait

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halRestoreSleepLevel?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halRestoreSleepLevel
    555          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     HalTimerElapsed                    1      0     40
     TimerElapsed                       0      0     12
     halRestoreSleepLevel               0      0      0
     halSetSleepMode                    0      0     20
     halSleep                           2      0     20
       -> MAC_PwrNextTimeout            0      0     40
       -> MAC_PwrNextTimeout            0      0     40
       -> halAssertHandler              0      0     40
       -> MAC_PwrOffReq                 0      0     40
       -> HalKeyEnterSleep              0      0     40
       -> HalLedEnterSleep              0      0     40
       -> halSleepSetTimer              0      0     40
       -> halSleepSetTimer              0      0     40
       -> halSetSleepMode               0      0     40
       -> HalTimerElapsed               0      0     40
       -> HalLedExitSleep               0      0     40
       -> HalKeyExitSleep               0      0     40
       -> MAC_PwrOnReq                  0      0     40
     halSleepSetTimer                   1      0     40
     halSleepTimerIsr                  15      0      0
       -> macMcuTimer2OverflowWorkaround
                                       30      0      0
     halSleepWait                       0      0      0


   Segment part sizes:

     Function/Label                Bytes
     --------------                -----
     PCON                             1
     ST0                              1
     ST1                              1
     ST2                              1
     IEN2                             1
     _A_IEN0                          1
     STLOAD                           1
     _A_IEN1                          1
     SLEEPCMD                         1
     _A_IRCON                         1
     halSetSleepMode                  7
     halPwrMgtMode                    1
     halSleepTimerStart               4
     halAccumulatedSleepTime          4
     halSleep                       626
     ?Subroutine2                    10
     ?Subroutine0                    12
     ?Subroutine1                     8
     halSleepSetTimer               142
     TimerElapsed                    26
     HalTimerElapsed                122
     halSleepWait                    31
     halRestoreSleepLevel             3
     halSleepTimerIsr                22
     ??halSleepTimerIsr??INTVEC 43    3
     __Constant_0                     4
     __Constant_64                    4
     __Constant_1f                    4
     __Constant_2d                    4
     __Constant_185197                4
     __Constant_ffe7ae6a              4
     __Constant_185196                4
     __Constant_29f                   4
     __Constant_ffffffef              4
     __Constant_11                    4
     __Constant_ffffff                4
     __Constant_7d                    4
     __Constant_fff                   4
     ??halSetSleepMode?relay          6
     ??halSleep?relay                 6
     ??halSleepSetTimer?relay         6
     ??TimerElapsed?relay             6
     ??HalTimerElapsed?relay          6
     ??halSleepWait?relay             6
     ??halRestoreSleepLevel?relay     6

 
 980 bytes in segment BANKED_CODE
  42 bytes in segment BANK_RELAYS
   3 bytes in segment INTVEC
  22 bytes in segment NEAR_CODE
  10 bytes in segment SFR_AN
   7 bytes in segment SLEEP_CODE
  52 bytes in segment XDATA_ROM_C
   9 bytes in segment XDATA_Z
 
 1 051 bytes of CODE  memory (+  3 bytes shared)
     0 bytes of CONST memory (+ 52 bytes shared)
     0 bytes of DATA  memory (+ 10 bytes shared)
     9 bytes of XDATA memory

Errors: none
Warnings: none
